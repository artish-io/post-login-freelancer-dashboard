import { NextRequest, NextResponse } from 'next/server';

// Hierarchical project + tasks
import { UnifiedStorageService } from '@/lib/storage/unified-storage-service';
import { readAllTasks, convertHierarchicalToLegacy } from '@/lib/project-tasks/hierarchical-storage';

// Hierarchical invoices accessors
import { getAllInvoices, saveInvoice } from '@/lib/invoice-storage';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { projectId, freelancerId } = body;

    // Validate body and keep projectId as string
    if (typeof projectId !== 'string' || !projectId.trim()) {
      return NextResponse.json({ error: 'Invalid projectId' }, { status: 400 });
    }
    if (typeof freelancerId !== 'number') {
      return NextResponse.json({ error: 'Missing freelancerId' }, { status: 400 });
    }

    // Read project via UnifiedStorageService (no numeric casts)
    const projectInfo = await UnifiedStorageService.readProject(projectId);
    if (!projectInfo) {
      return NextResponse.json({ error: 'Project not found' }, { status: 404 });
    }

    // Read tasks hierarchically and convert to legacy list for compatibility
    const hierarchicalTasks = await readAllTasks();
    const allProjectTasks = convertHierarchicalToLegacy(hierarchicalTasks);
    const projectTasks = allProjectTasks.find((pt: any) => pt.projectId === projectId);
    if (!projectTasks) {
      return NextResponse.json({ error: 'Project tasks not found' }, { status: 404 });
    }

    // Read invoices from hierarchical store
    const invoices = await getAllInvoices();

    const tasks = projectTasks.tasks || [];

    // Get already invoiced tasks
    const invoicedTaskIds = new Set();
    const invoicedTaskTitles = new Set();
    invoices
      .filter((invoice: any) => invoice.projectId === projectId)
      .forEach((invoice: any) => {
        if (invoice.milestones) {
          invoice.milestones.forEach((milestone: any) => {
            if (milestone.taskId) invoicedTaskIds.add(milestone.taskId);
            if (milestone.title || milestone.description) {
              invoicedTaskTitles.add(milestone.title || milestone.description);
            }
          });
        }
        if (invoice.milestoneDescription) {
          invoicedTaskTitles.add(invoice.milestoneDescription);
        }
      });

    // Find available tasks
    const availableTasks = tasks.filter((task: any) => {
      return task.status?.toLowerCase() === 'approved' &&
             !invoicedTaskIds.has(task.id) &&
             !invoicedTaskTitles.has(task.title) &&
             !task.invoicePaid;
    });

    if (availableTasks.length === 0) {
      return NextResponse.json({ error: 'No available tasks to invoice' }, { status: 400 });
    }

    // Calculate rate per task
    let ratePerTask = 0;
    if (projectInfo.totalBudget && projectInfo.totalTasks) {
      if (projectInfo.invoicingMethod === 'completion') {
        const upfrontCommitment = projectInfo.upfrontCommitment || 0;
        const milestonePool = projectInfo.totalBudget - upfrontCommitment;
        ratePerTask = milestonePool / projectInfo.totalTasks;
      } else {
        ratePerTask = projectInfo.totalBudget / projectInfo.totalTasks;
      }
    }

    // Create milestones from available tasks
    const milestones = availableTasks.map((task: any) => ({
      title: task.title || `Task ${task.id}`,
      description: task.description || task.title || `Task ${task.id}`,
      rate: ratePerTask > 0 ? ratePerTask : 0,
      taskId: task.id
    }));

    const totalAmount = milestones.reduce((sum: number, m: any) => sum + m.rate, 0);

    // Generate invoice object (unchanged fields; ensure projectId is the string)
    const invoiceNumber = `INV-${projectId}-${Date.now()}`;

    if (!projectInfo.commissionerId) {
      return NextResponse.json({ error: 'Project missing commissioner information' }, { status: 400 });
    }

    const invoiceData = {
      invoiceNumber,
      freelancerId: Number(freelancerId),
      commissionerId: projectInfo.commissionerId,
      projectId: projectId, // keep as string
      projectTitle: projectInfo.title,
      issueDate: new Date().toISOString().split('T')[0],
      dueDate: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 14 days from now
      totalAmount: totalAmount,
      status: 'draft' as const,
      milestones: milestones,
      isCustomProject: false,
      createdAt: new Date().toISOString(),
      autoGenerated: true
    };

    // Persist via hierarchical invoice storage
    await saveInvoice(invoiceData);

    // Return success payload identical to current shape
    return NextResponse.json({ success: true, invoiceNumber, invoiceData });

  } catch (error) {
    const msg = error instanceof Error ? error.message : 'Unknown error';
    console.error('Error generating invoice for project:', msg);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
