// src/lib/invoice-storage.ts
import 'server-only';
import { readFile, writeFile, readdir, stat } from 'fs/promises';
import * as fs from 'fs';
import path from 'path';

import { InvoiceStatus, InvoiceType } from './invoice-status-definitions';

export interface Invoice {
  invoiceNumber: string;
  freelancerId: number | string;
  projectId: string | number | null;
  commissionerId: number;
  projectTitle: string;
  milestoneDescription?: string;
  milestoneNumber?: number;
  issueDate: string;
  dueDate: string;
  totalAmount: number;
  status: InvoiceStatus; // Use the well-defined status type
  invoiceType?: InvoiceType; // Track invoice type (manual, auto_milestone, auto_completion)
  milestones: Array<{
    description: string;
    rate: number;
    title?: string;
    taskId?: number;
  }>;
  isCustomProject?: boolean;
  isManualInvoice?: boolean;
  parentInvoiceNumber?: string;
  paidDate?: string;
  sentDate?: string;
  createdAt?: string;
  updatedAt?: string;
  paymentDetails?: {
    paymentId: string;
    paymentMethod: string;
    platformFee: number;
    freelancerAmount: number;
    currency: string;
    processedAt: string;
  };
  // Auto-milestone specific fields
  autoPaymentAttempts?: number;
  lastPaymentAttempt?: string;
  nextRetryDate?: string;
  paymentFailureReason?: string;
  // Legacy fields for backward compatibility
  id?: number;
  autoGenerated?: boolean;
  paidAmount?: number;
  sentAt?: string;
  versions?: any[];
}

// Helper function to parse date from various formats
function parseInvoiceDate(dateStr: string): Date {
  if (!dateStr) return new Date();
  
  // Handle ISO string format (e.g., "2025-07-27T16:55:28.237Z")
  if (dateStr.includes('T')) {
    return new Date(dateStr);
  }
  
  // Handle simple date format (e.g., "2025-06-01")
  return new Date(dateStr + 'T00:00:00.000Z');
}

// Helper function to format date parts
function getDateParts(date: Date): { year: string; month: string; day: string } {
  if (!date || isNaN(date.getTime())) {
    date = new Date();
  }
  
  const year = date.getFullYear().toString();
  const month = date.toLocaleString('en-US', { month: 'long' }); // e.g., "July"
  const day = date.getDate().toString().padStart(2, '0'); // e.g., "01"
  
  return { year, month, day };
}

// Helper function to ensure directory exists
async function ensureDir(dirPath: string): Promise<void> {
  try {
    await stat(dirPath);
  } catch {
    const { mkdir } = await import('fs/promises');
    await mkdir(dirPath, { recursive: true });
  }
}

// Get the file path for an invoice
function getInvoiceFilePath(invoice: Invoice): string {
  const issueDate = parseInvoiceDate(invoice.issueDate);
  const { year, month, day } = getDateParts(issueDate);
  const projectId = invoice.projectId ? invoice.projectId.toString() : 'custom';

  return path.join(
    process.cwd(),
    'data',
    'invoices',
    year,
    month,
    day,
    projectId,
    `${invoice.invoiceNumber}.json`
  );
}

// Helper function to get file path by invoice number and project ID (for direct access)
function getInvoiceFilePathByNumber(invoiceNumber: string, projectId: string): string {
  const now = new Date();
  const { year, month, day } = getDateParts(now);

  return path.join(
    process.cwd(),
    'data',
    'invoices',
    year,
    month,
    day,
    projectId,
    `${invoiceNumber}.json`
  );
}

// Get directory path for invoices
function getInvoiceDirectoryPath(invoice: Invoice): string {
  const issueDate = parseInvoiceDate(invoice.issueDate);
  const { year, month, day } = getDateParts(issueDate);
  const projectId = invoice.projectId ? invoice.projectId.toString() : 'custom';

  return path.join(
    process.cwd(),
    'data',
    'invoices',
    year,
    month,
    day,
    projectId
  );
}

// Helper function to determine if a new invoice should replace an existing one
function shouldReplaceInvoice(existing: Invoice, candidate: Invoice): boolean {
  // Status priority: paid > sent > draft
  const statusPriority: Record<string, number> = { 'paid': 3, 'sent': 2, 'draft': 1 };

  const existingPriority = statusPriority[existing.status] || 0;
  const candidatePriority = statusPriority[candidate.status] || 0;

  // If candidate has higher status priority, replace
  if (candidatePriority > existingPriority) {
    return true;
  }

  // If same status priority, use timestamp (most recent wins)
  if (candidatePriority === existingPriority) {
    const existingTime = existing.updatedAt || existing.createdAt || existing.issueDate;
    const candidateTime = candidate.updatedAt || candidate.createdAt || candidate.issueDate;

    if (candidateTime && existingTime) {
      return new Date(candidateTime).getTime() > new Date(existingTime).getTime();
    }
  }

  // Default: don't replace
  return false;
}

// Save an invoice to the hierarchical structure
export async function saveInvoice(invoice: Invoice): Promise<void> {
  const dirPath = getInvoiceDirectoryPath(invoice);
  await ensureDir(dirPath);

  // Use invoice number as filename for consistency
  const filePath = getInvoiceFilePath(invoice);
  await writeFile(filePath, JSON.stringify(invoice, null, 2));
}

// Get all invoices (with optional filters)
export async function getAllInvoices(filters?: {
  freelancerId?: number | string;
  commissionerId?: number;
  projectId?: number | string;
  status?: string;
  startDate?: string;
  endDate?: string;
}): Promise<Invoice[]> {
  const invoices: Invoice[] = [];
  const baseDir = path.join(process.cwd(), 'data', 'invoices');
  
  try {
    await stat(baseDir);
  } catch {
    return [];
  }
  
  async function scanDirectory(dirPath: string): Promise<void> {
    try {
      const entries = await readdir(dirPath, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(dirPath, entry.name);
        
        if (entry.isDirectory()) {
          await scanDirectory(fullPath);
        } else if (entry.name.endsWith('.json')) {
          try {
            const data = await readFile(fullPath, 'utf-8');
            const invoice = JSON.parse(data) as Invoice;
            
            // Apply filters
            if (filters) {
              if (filters.freelancerId && invoice.freelancerId.toString() !== filters.freelancerId.toString()) continue;
              if (filters.commissionerId && invoice.commissionerId !== filters.commissionerId) continue;
              if (filters.projectId && invoice.projectId?.toString() !== filters.projectId.toString()) continue;
              if (filters.status && invoice.status !== filters.status) continue;
              
              if (filters.startDate || filters.endDate) {
                const invoiceDate = parseInvoiceDate(invoice.issueDate);
                if (filters.startDate && invoiceDate < new Date(filters.startDate)) continue;
                if (filters.endDate && invoiceDate > new Date(filters.endDate)) continue;
              }
            }
            
            invoices.push(invoice);
          } catch (error) {
            console.error(`Error reading invoice file ${fullPath}:`, error);
          }
        }
      }
    } catch (error) {
      console.error(`Error scanning directory ${dirPath}:`, error);
    }
  }
  
  await scanDirectory(baseDir);

  // Deduplicate invoices by invoice number, prioritizing paid > sent > draft
  const deduplicatedInvoices = new Map<string, Invoice>();

  for (const invoice of invoices) {
    const existing = deduplicatedInvoices.get(invoice.invoiceNumber);

    if (!existing) {
      // No existing invoice, add this one
      deduplicatedInvoices.set(invoice.invoiceNumber, invoice);
    } else {
      // Determine which invoice to keep based on priority
      const shouldReplace = shouldReplaceInvoice(existing, invoice);
      if (shouldReplace) {
        deduplicatedInvoices.set(invoice.invoiceNumber, invoice);
      }
    }
  }

  // Convert back to array and sort by issue date (newest first)
  return Array.from(deduplicatedInvoices.values()).sort((a, b) => {
    const dateA = parseInvoiceDate(a.issueDate);
    const dateB = parseInvoiceDate(b.issueDate);
    return dateB.getTime() - dateA.getTime();
  });
}

// Get invoice by invoice number
export async function getInvoiceByNumber(invoiceNumber: string): Promise<Invoice | null> {
  const allInvoices = await getAllInvoices();
  return allInvoices.find(inv => inv.invoiceNumber === invoiceNumber) || null;
}

// Get invoices by project ID
export async function getInvoicesByProjectId(projectId: number | string): Promise<Invoice[]> {
  return getAllInvoices({ projectId });
}

// Get invoices by freelancer ID
export async function getInvoicesByFreelancerId(freelancerId: number | string): Promise<Invoice[]> {
  return getAllInvoices({ freelancerId });
}

// Get invoices by commissioner ID
export async function getInvoicesByCommissionerId(commissionerId: number): Promise<Invoice[]> {
  return getAllInvoices({ commissionerId });
}

// Update an existing invoice
export async function updateInvoice(invoiceNumber: string, updates: Partial<Invoice>): Promise<boolean> {
  const invoice = await getInvoiceByNumber(invoiceNumber);
  if (!invoice) return false;

  const updatedInvoice = { ...invoice, ...updates, updatedAt: new Date().toISOString() };
  await saveInvoice(updatedInvoice);
  return true;
}

// Update an existing invoice with project context (for handling duplicates)
export async function updateInvoiceByProjectId(
  invoiceNumber: string,
  projectId: string | number,
  updates: Partial<Invoice>
): Promise<boolean> {
  console.log('üîç updateInvoiceByProjectId: Searching for invoice:', {
    invoiceNumber,
    projectId,
    projectIdType: typeof projectId
  });

  try {
    // Try direct file read first (more reliable for recently created invoices)
    const invoiceFilePath = getInvoiceFilePathByNumber(invoiceNumber, projectId.toString());
    console.log('üìÅ updateInvoiceByProjectId: Trying direct file read:', invoiceFilePath);

    if (fs.existsSync(invoiceFilePath)) {
      console.log('‚úÖ updateInvoiceByProjectId: Found invoice file directly');
      const invoiceData = JSON.parse(fs.readFileSync(invoiceFilePath, 'utf8'));
      const updatedInvoice = { ...invoiceData, ...updates, updatedAt: new Date().toISOString() };
      await saveInvoice(updatedInvoice);
      console.log('‚úÖ updateInvoiceByProjectId: Invoice updated successfully via direct file access');
      return true;
    }

    console.log('üìã updateInvoiceByProjectId: Direct file not found, falling back to getAllInvoices');
  } catch (directError) {
    console.warn('‚ö†Ô∏è updateInvoiceByProjectId: Direct file read failed:', directError);
  }

  // Fallback to getAllInvoices approach
  const allInvoices = await getAllInvoices();
  console.log('üìã updateInvoiceByProjectId: Found invoices for project:',
    allInvoices.filter(inv => inv.projectId?.toString() === projectId.toString()).map(inv => ({
      number: inv.invoiceNumber,
      projectId: inv.projectId,
      status: inv.status
    }))
  );

  const targetInvoice = allInvoices.find(inv =>
    inv.invoiceNumber === invoiceNumber &&
    inv.projectId?.toString() === projectId.toString()
  );

  console.log('üéØ updateInvoiceByProjectId: Target invoice found:', !!targetInvoice);

  if (!targetInvoice) {
    console.error('‚ùå updateInvoiceByProjectId: Invoice not found via getAllInvoices either');
    return false;
  }

  const updatedInvoice = { ...targetInvoice, ...updates, updatedAt: new Date().toISOString() };
  await saveInvoice(updatedInvoice);
  console.log('‚úÖ updateInvoiceByProjectId: Invoice updated successfully via getAllInvoices');
  return true;
}

// Delete an invoice
export async function deleteInvoice(invoiceNumber: string): Promise<boolean> {
  const invoice = await getInvoiceByNumber(invoiceNumber);
  if (!invoice) return false;
  
  const filePath = getInvoiceFilePath(invoice);
  try {
    const { unlink } = await import('fs/promises');
    await unlink(filePath);
    return true;
  } catch {
    return false;
  }
}

// Get invoices by date range
export async function getInvoicesByDateRange(startDate: string, endDate: string): Promise<Invoice[]> {
  return getAllInvoices({ startDate, endDate });
}

// Legacy compatibility: Get all invoices in the old format (array)
export async function getLegacyInvoicesArray(): Promise<Invoice[]> {
  return getAllInvoices();
}
