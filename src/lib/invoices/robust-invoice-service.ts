/**
 * Robust Invoice Generation Service
 * 
 * Implements retry mechanisms, proper error handling, and transaction integrity
 * for invoice generation operations
 */

import { readProject } from '../projects-utils';
import { readProjectTasks } from '../project-tasks/hierarchical-storage';
import { saveInvoice, getAllInvoices } from '../invoice-storage';

export interface InvoiceGenerationRequest {
  taskId: number;
  projectId: number;
  freelancerId: number;
  commissionerId: number;
  taskTitle: string;
  projectTitle: string;
  invoiceType: 'completion' | 'milestone';
  amount?: number;
}

export interface InvoiceGenerationResult {
  success: boolean;
  invoiceNumber?: string;
  invoiceId?: string;
  amount?: number;
  error?: string;
  retryAttempt?: number;
  generatedAt: string;
}

export interface RetryConfig {
  maxAttempts: number;
  baseDelayMs: number;
  maxDelayMs: number;
  backoffMultiplier: number;
}

const DEFAULT_RETRY_CONFIG: RetryConfig = {
  maxAttempts: 3,
  baseDelayMs: 1000,
  maxDelayMs: 10000,
  backoffMultiplier: 2
};

/**
 * Generate invoice with retry logic and transaction integrity
 */
export async function generateInvoiceWithRetry(
  request: InvoiceGenerationRequest,
  retryConfig: RetryConfig = DEFAULT_RETRY_CONFIG
): Promise<InvoiceGenerationResult> {
  let lastError: Error | null = null;
  
  for (let attempt = 1; attempt <= retryConfig.maxAttempts; attempt++) {
    try {
      console.log(`üìÑ Generating invoice (attempt ${attempt}/${retryConfig.maxAttempts}) for task ${request.taskId}...`);
      
      const result = await generateInvoice(request);
      
      if (result.success) {
        console.log(`‚úÖ Invoice generated successfully on attempt ${attempt}: ${result.invoiceNumber}`);
        return {
          ...result,
          retryAttempt: attempt
        };
      } else {
        throw new Error(result.error || 'Invoice generation failed');
      }
      
    } catch (error) {
      lastError = error instanceof Error ? error : new Error('Unknown error');
      console.warn(`‚ö†Ô∏è Invoice generation attempt ${attempt} failed:`, lastError.message);
      
      // Don't retry on the last attempt
      if (attempt < retryConfig.maxAttempts) {
        const delay = Math.min(
          retryConfig.baseDelayMs * Math.pow(retryConfig.backoffMultiplier, attempt - 1),
          retryConfig.maxDelayMs
        );
        
        console.log(`‚è≥ Retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  console.error(`‚ùå Invoice generation failed after ${retryConfig.maxAttempts} attempts:`, lastError?.message);
  
  return {
    success: false,
    error: `Failed after ${retryConfig.maxAttempts} attempts: ${lastError?.message || 'Unknown error'}`,
    retryAttempt: retryConfig.maxAttempts,
    generatedAt: new Date().toISOString()
  };
}

/**
 * Core invoice generation logic
 */
async function generateInvoice(request: InvoiceGenerationRequest): Promise<InvoiceGenerationResult> {
  try {
    // Validate request
    const validation = await validateInvoiceRequest(request);
    if (!validation.isValid) {
      throw new Error(`Invalid request: ${validation.errors.join(', ')}`);
    }

    // Get project information
    const project = await readProject(request.projectId);
    if (!project) {
      throw new Error(`Project ${request.projectId} not found`);
    }

    // Calculate invoice amount
    const amount = request.amount || await calculateInvoiceAmount(request, project);
    
    // Generate unique invoice number
    const invoiceNumber = await generateUniqueInvoiceNumber(request);
    
    // Create invoice data
    const invoiceData = {
      invoiceNumber,
      freelancerId: request.freelancerId,
      projectId: request.projectId,
      commissionerId: request.commissionerId,
      projectTitle: request.projectTitle,
      milestoneDescription: request.taskTitle,
      milestoneNumber: request.taskId,
      issueDate: new Date().toISOString().split('T')[0],
      dueDate: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      totalAmount: amount,
      status: 'sent' as const,
      invoiceType: request.invoiceType,
      milestones: [{
        description: request.taskTitle,
        rate: amount,
        taskId: request.taskId,
        approvedAt: new Date().toISOString()
      }],
      paymentDetails: {
        freelancerAmount: Math.round((amount * 0.95) * 100) / 100, // 5% platform fee
        platformFee: Math.round((amount * 0.05) * 100) / 100
      },
      invoicingMethod: request.invoiceType,
      isAutoGenerated: true,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    // Save invoice with transaction integrity
    await saveInvoiceWithIntegrity(invoiceData);
    
    console.log(`‚úÖ Invoice ${invoiceNumber} generated successfully for $${amount}`);
    
    return {
      success: true,
      invoiceNumber,
      invoiceId: invoiceNumber,
      amount,
      generatedAt: new Date().toISOString()
    };

  } catch (error) {
    console.error('Error in generateInvoice:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      generatedAt: new Date().toISOString()
    };
  }
}

/**
 * Validate invoice generation request
 */
async function validateInvoiceRequest(request: InvoiceGenerationRequest): Promise<{
  isValid: boolean;
  errors: string[];
}> {
  const errors: string[] = [];

  if (!request.taskId || request.taskId <= 0) {
    errors.push('Invalid task ID');
  }

  if (!request.projectId || request.projectId <= 0) {
    errors.push('Invalid project ID');
  }

  if (!request.freelancerId || request.freelancerId <= 0) {
    errors.push('Invalid freelancer ID');
  }

  if (!request.commissionerId || request.commissionerId <= 0) {
    errors.push('Invalid commissioner ID');
  }

  if (!request.taskTitle || request.taskTitle.trim().length === 0) {
    errors.push('Task title is required');
  }

  if (!request.projectTitle || request.projectTitle.trim().length === 0) {
    errors.push('Project title is required');
  }

  if (!['completion', 'milestone'].includes(request.invoiceType)) {
    errors.push('Invalid invoice type');
  }

  // Check if invoice already exists for this task (optimized to check project invoices only)
  try {
    const projectInvoices = await getAllInvoices({ projectId: request.projectId });
    const duplicateInvoice = projectInvoices.find(invoice =>
      invoice.milestones?.some(milestone => milestone.taskId === request.taskId)
    );

    if (duplicateInvoice) {
      errors.push(`Invoice already exists for task ${request.taskId}: ${duplicateInvoice.invoiceNumber}`);
    }
  } catch (error) {
    console.warn('Could not check for duplicate invoices:', error);
    // Don't fail validation if we can't check for duplicates
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}

/**
 * Calculate invoice amount based on project and task
 * Enhanced to handle completion-based vs milestone-based correctly
 */
async function calculateInvoiceAmount(
  request: InvoiceGenerationRequest,
  project: any
): Promise<number> {
  try {
    const totalBudget = project.totalBudget || project.budget?.upper || project.budget?.lower || 5000;
    const totalTasks = project.totalTasks || 1;

    if (request.invoiceType === 'completion') {
      // COMPLETION-BASED: 12% upfront already paid, remaining 88% divided by tasks
      const upfrontCommitment = project.upfrontCommitment || project.upfrontAmount || (totalBudget * 0.12);
      const remainingBudget = totalBudget - upfrontCommitment;

      // Check if any tasks have already been paid out manually
      const paidTasks = await getPaidTasksCount(project.projectId);
      const remainingTasks = Math.max(1, totalTasks - paidTasks);

      // Redistribute remaining budget across remaining tasks
      const amountPerTask = remainingBudget / remainingTasks;

      console.log(`üí∞ Completion-based calculation for project ${project.projectId}:`, {
        totalBudget,
        upfrontCommitment,
        remainingBudget,
        totalTasks,
        paidTasks,
        remainingTasks,
        amountPerTask
      });

      return Math.round(amountPerTask * 100) / 100;

    } else if (request.invoiceType === 'milestone') {
      // MILESTONE-BASED: Total budget evenly distributed across ALL tasks
      // No upfront payment for milestone-based projects
      const amountPerMilestone = totalBudget / totalTasks;

      console.log(`üí∞ Milestone-based calculation for project ${project.projectId}:`, {
        totalBudget,
        totalTasks,
        amountPerMilestone,
        note: 'Each milestone gets equal share of total budget'
      });

      return Math.round(amountPerMilestone * 100) / 100;
    }

    // Fallback for unknown invoice types
    console.warn(`Unknown invoice type: ${request.invoiceType}, using default calculation`);
    return Math.round((totalBudget / totalTasks) * 100) / 100;

  } catch (error) {
    console.warn('Error calculating invoice amount, using default:', error);
    return 1000; // Default amount
  }
}

/**
 * Get count of tasks that have already been paid out manually
 */
async function getPaidTasksCount(projectId: number): Promise<number> {
  try {
    // Only get invoices for this specific project with paid status
    const projectInvoices = await getAllInvoices({
      projectId: projectId,
      status: 'paid'
    });

    // Count unique tasks that have been paid
    const paidTaskIds = new Set();
    projectInvoices.forEach(invoice => {
      if (invoice.milestones) {
        invoice.milestones.forEach((milestone: any) => {
          if (milestone.taskId) {
            paidTaskIds.add(milestone.taskId);
          }
        });
      }
    });

    return paidTaskIds.size;
  } catch (error) {
    console.warn('Error getting paid tasks count:', error);
    return 0;
  }
}

/**
 * Generate unique invoice number
 */
async function generateUniqueInvoiceNumber(request: InvoiceGenerationRequest): Promise<string> {
  const prefix = request.invoiceType === 'completion' ? 'COMP' : 'MILE';
  const timestamp = Date.now();
  const random = Math.floor(Math.random() * 1000);
  
  return `${prefix}_${request.projectId}_${request.taskId}_${timestamp}_${random}`;
}

/**
 * Save invoice with transaction integrity
 */
async function saveInvoiceWithIntegrity(invoiceData: any): Promise<void> {
  try {
    // Save to hierarchical storage
    await saveInvoice(invoiceData);
    
    // TODO: Add additional integrity checks here
    // - Verify the file was written correctly
    // - Update any invoice indexes
    // - Log the transaction
    
    console.log(`üíæ Invoice ${invoiceData.invoiceNumber} saved with integrity checks`);
    
  } catch (error) {
    console.error('Error saving invoice with integrity:', error);
    throw new Error(`Failed to save invoice: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}
